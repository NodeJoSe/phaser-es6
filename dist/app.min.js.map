{"version":3,"names":[],"mappings":"","sources":["app.min.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _load = require('./states/load');\n\nvar _load2 = _interopRequireDefault(_load);\n\nvar _menu = require('./states/menu');\n\nvar _menu2 = _interopRequireDefault(_menu);\n\nvar _play = require('./states/play');\n\nvar _play2 = _interopRequireDefault(_play);\n\nvar _gameover = require('./states/gameover');\n\nvar _gameover2 = _interopRequireDefault(_gameover);\n\nvar _victory = require('./states/victory');\n\nvar _victory2 = _interopRequireDefault(_victory);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Game = function (_Phaser$Game) {\n  _inherits(Game, _Phaser$Game);\n\n  function Game() {\n    var _this;\n\n    _classCallCheck(this, Game);\n\n    return _this = _possibleConstructorReturn(this, (Game.__proto__ || Object.getPrototypeOf(Game)).call(this, 800, 600, Phaser.CANVAS, 'game', {\n      create: function create() {\n        _this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\n\n        _this.state.add('load', _load2.default);\n        _this.state.add('menu', _menu2.default);\n        _this.state.add('play', _play2.default);\n        _this.state.add('gameover', _gameover2.default);\n        _this.state.add('victory', _victory2.default);\n        _this.state.start('load');\n      }\n    }));\n  }\n\n  return Game;\n}(Phaser.Game);\n\nnew Game();\n\n},{\"./states/gameover\":3,\"./states/load\":4,\"./states/menu\":5,\"./states/play\":6,\"./states/victory\":7}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Wizard = function (_Phaser$Sprite) {\n  _inherits(Wizard, _Phaser$Sprite);\n\n  function Wizard(game, x, y) {\n    _classCallCheck(this, Wizard);\n\n    var _this = _possibleConstructorReturn(this, (Wizard.__proto__ || Object.getPrototypeOf(Wizard)).call(this, game, x, y, 'wizard'));\n\n    _this.anchor.setTo(0.5, 0.5);\n\n    _this.scale.setTo(0.65, 0.65);\n\n    _this.animations.add('right', [0, 1, 2]);\n\n    _this.animations.add('left', [3, 4, 5]);\n\n    _this.game.physics.enable(_this, Phaser.Physics.ARCADE);\n\n    _this.body.drag.set(100);\n\n    _this.body.maxVelocity.set(500);\n\n    _this.body.collideWorldBounds = true;\n    _this.body.width -= 32;\n    _this.body.height -= 32;\n    return _this;\n  }\n\n  _createClass(Wizard, [{\n    key: 'move',\n    value: function move(cursors) {\n      if (cursors.up.isDown) {\n        this.body.acceleration.y = -300;\n      } else if (cursors.down.isDown) {\n        this.body.acceleration.y = 300;\n      } else {\n        this.body.acceleration.y = 0;\n      }\n      if (cursors.left.isDown) {\n        this.body.acceleration.x = -300;\n        this.animations.play('left', 4, true);\n      } else if (cursors.right.isDown) {\n        this.body.acceleration.x = 300;\n        this.animations.play('right', 4, true);\n      } else {\n        this.body.acceleration.x = 0;\n      }\n    }\n  }]);\n\n  return Wizard;\n}(Phaser.Sprite);\n\nexports.default = Wizard;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar GameOver = function (_Phaser$State) {\n  _inherits(GameOver, _Phaser$State);\n\n  function GameOver() {\n    _classCallCheck(this, GameOver);\n\n    return _possibleConstructorReturn(this, (GameOver.__proto__ || Object.getPrototypeOf(GameOver)).apply(this, arguments));\n  }\n\n  _createClass(GameOver, [{\n    key: 'create',\n    value: function create() {\n      var _this2 = this;\n\n      var textStyle = {\n        font: '45px Arial',\n        alight: 'center',\n        stroke: 'red',\n        fill: 'red'\n      };\n\n      var title = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 100, 'GAME OVER', textStyle);\n      title.anchor.set(0.5);\n\n      textStyle.font = '36px Arial';\n\n      var instructions = this.game.add.text(this.game.world.centerX, this.game.world.centerY, '\"s\" key to play again', textStyle);\n      instructions.anchor.set(0.5);\n\n      var sKey = this.game.input.keyboard.addKey(Phaser.KeyCode.S);\n      sKey.onDown.addOnce(function () {\n        return _this2.game.state.start('play');\n      });\n    }\n  }]);\n\n  return GameOver;\n}(Phaser.State);\n\nexports.default = GameOver;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Load = function (_Phaser$State) {\n  _inherits(Load, _Phaser$State);\n\n  function Load() {\n    _classCallCheck(this, Load);\n\n    return _possibleConstructorReturn(this, (Load.__proto__ || Object.getPrototypeOf(Load)).apply(this, arguments));\n  }\n\n  _createClass(Load, [{\n    key: 'preload',\n    value: function preload() {\n      var textStyle = {\n        font: '45px Arial',\n        alight: 'center',\n        stroke: 'blue',\n        fill: 'blue'\n      };\n\n      this.game.add.text(80, 150, 'loading...', textStyle);\n\n      this.game.load.spritesheet('wizard', 'assets/wizardsprite.png', 95, 123, 6);\n    }\n  }, {\n    key: 'create',\n    value: function create() {\n      this.game.state.start('menu');\n    }\n  }]);\n\n  return Load;\n}(Phaser.State);\n\nexports.default = Load;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Menu = function (_Phaser$State) {\n  _inherits(Menu, _Phaser$State);\n\n  function Menu() {\n    _classCallCheck(this, Menu);\n\n    return _possibleConstructorReturn(this, (Menu.__proto__ || Object.getPrototypeOf(Menu)).apply(this, arguments));\n  }\n\n  _createClass(Menu, [{\n    key: 'create',\n    value: function create() {\n      var _this2 = this;\n\n      var textStyle = {\n        font: '45px Arial',\n        alight: 'center',\n        stroke: 'blue',\n        fill: 'blue'\n      };\n\n      var title = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 100, 'ES2015 Wizard', textStyle);\n\n      title.anchor.set(0.5);\n\n      textStyle.font = '36px Arial';\n\n      var instructions = this.game.add.text(this.game.world.centerX, this.game.world.centerY, '\"s\" key to start', textStyle);\n\n      instructions.anchor.set(0.5);\n\n      var controlMessage = this.game.add.text(this.game.world.centerX, this.game.world.centerY + 150, 'use arrow keys to move', textStyle);\n\n      controlMessage.anchor.set(0.5);\n\n      var muteMessage = this.game.add.text(this.game.world.centerX, this.game.world.centerY + 225, '\"SPACEBAR\" to win.', textStyle);\n\n      muteMessage.anchor.set(0.5);\n\n      var sKey = this.game.input.keyboard.addKey(Phaser.KeyCode.S);\n\n      sKey.onDown.addOnce(function () {\n        return _this2.game.state.start('play');\n      });\n    }\n  }]);\n\n  return Menu;\n}(Phaser.State);\n\nexports.default = Menu;\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _wizard = require('../sprites/wizard');\n\nvar _wizard2 = _interopRequireDefault(_wizard);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Play = function (_Phaser$State) {\n  _inherits(Play, _Phaser$State);\n\n  function Play() {\n    _classCallCheck(this, Play);\n\n    return _possibleConstructorReturn(this, (Play.__proto__ || Object.getPrototypeOf(Play)).apply(this, arguments));\n  }\n\n  _createClass(Play, [{\n    key: 'create',\n    value: function create() {\n      this.game.physics.startSystem(Phaser.Physics.ARCADE);\n\n      this.wizard = new _wizard2.default(this.game, 350, 300);\n      this.game.add.existing(this.wizard);\n\n      this.cursors = this.game.input.keyboard.createCursorKeys();\n      this.game.stage.backgroundColor = '#ffffff';\n      this.game.input.keyboard.addKeyCapture([Phaser.KeyCode.SPACEBAR]);\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      if (!this.startTime) {\n        this.startTime = Date.now();\n      }\n\n      // 20 seconds to win\n      if (Date.now() - this.startTime > 20000) {\n        this.startTime = 0;\n        this.game.state.start('gameover');\n      }\n\n      this.wizard.move(this.cursors);\n\n      if (this.game.input.keyboard.isDown(Phaser.KeyCode.SPACEBAR)) {\n        this.startTime = 0;\n        this.game.state.start('victory');\n      }\n    }\n  }]);\n\n  return Play;\n}(Phaser.State);\n\nexports.default = Play;\n\n},{\"../sprites/wizard\":2}],7:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Victory = function (_Phaser$State) {\n  _inherits(Victory, _Phaser$State);\n\n  function Victory() {\n    _classCallCheck(this, Victory);\n\n    return _possibleConstructorReturn(this, (Victory.__proto__ || Object.getPrototypeOf(Victory)).apply(this, arguments));\n  }\n\n  _createClass(Victory, [{\n    key: 'create',\n    value: function create() {\n      var _this2 = this;\n\n      var textStyle = {\n        font: '45px Arial',\n        alight: 'center',\n        stroke: 'black',\n        fill: 'red'\n      };\n\n      var title = this.game.add.text(this.game.world.centerX, this.game.world.centerY - 100, 'Victory!', textStyle);\n      title.anchor.set(0.5);\n\n      textStyle.font = '36px Arial';\n\n      var instructions = this.game.add.text(this.game.world.centerX, this.game.world.centerY, '\"s\" key to play again', textStyle);\n      instructions.anchor.set(0.5);\n\n      var sKey = this.game.input.keyboard.addKey(Phaser.KeyCode.S);\n      sKey.onDown.addOnce(function () {\n        return _this2.game.state.start('play');\n      });\n    }\n  }]);\n\n  return Victory;\n}(Phaser.State);\n\nexports.default = Victory;\n\n},{}]},{},[1]);\n"],"file":"../phaser-es6/app.min.js"}